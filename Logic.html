<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>Logic</title>
<script type="text/javascript" src="jquery-1.8.3.js"></script>
<script type="text/javascript" src="main.js"></script>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Logic</h1>

<div class="code code-tight">
</div>

<div class="doc">
<a name="lab190"></a><h1 class="section">Logic：Coq中的逻辑系统</h1>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Require</span> <span class="id" type="keyword">Export</span> <span class="id" type="var">BasicTactics</span>.<br/>

<br/>
</div>

<div class="doc">
Coq内置的逻辑系统十分地小：仅有的基本操作只有<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>定义，全称量化
（<span class="inlinecode"><span style="font-family: arial;">∀</span></span>）以及蕴含（<span class="inlinecode"><span style="font-family: arial;">→</span></span>）三种，而所有其他常见的逻辑连接符——合取、析取、否
定、存在量化，甚至相等，都能够用这三个基本操作表示。这一章将解释这种表
示方法并展示如何使用之前我们接触到的证明策略来得出对含有这些连接词的命
题的逻辑推理的范式。

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab191"></a><h1 class="section">命题</h1>

<div class="paragraph"> </div>

 在之前的章节中我们已经看到许多对于某些事实的陈述（ <i>命题</i> ）以及给出证实它们
的真实性的证据的方法（ <i>证明</i> ）。比方说，目前为止我们已经进行了许多命题的证
明；比如说形如<span class="inlinecode"><span class="id" type="var">e1</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">e2</span></span>的 <i>相等性命题</i> ，蕴含式（<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>），以及量化命题（<span class="inlinecode"><span style="font-family: arial;">∀</span></span> <span class="inlinecode"><span class="id" type="var">x</span>,</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">x</span></span>）的证明。  

<div class="paragraph"> </div>

 在Coq中，所有存在被证明的可能的事物的类型是<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>。 
<div class="paragraph"> </div>

 下面是一个可以被证明的命题： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (3 = 3).<br/>
<span class="comment">(* ===> Prop *)</span><br/>

<br/>
</div>

<div class="doc">
下面是一个无法被证明的命题： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> (<span style="font-family: arial;">∀</span>(<span class="id" type="var">n</span>:<span class="id" type="var">nat</span>), <span class="id" type="var">n</span> = 2).<br/>
<span class="comment">(* ===> Prop *)</span><br/>

<br/>
</div>

<div class="doc">
回想一下，<span class="inlinecode"><span class="id" type="keyword">Check</span></span>能够让Coq显示某个表达式的类型。 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab192"></a><h1 class="section">证明与证据</h1>

<div class="paragraph"> </div>

 在Coq中，命题与<span class="inlinecode"><span class="id" type="var">nat</span></span>之类的类型有着同样的地位。就像自然数<span class="inlinecode">0</span>，<span class="inlinecode">1</span>，<span class="inlinecode">2</span>是<span class="inlinecode"><span class="id" type="var">nat</span></span>的
元素一样，一个Coq命题<span class="inlinecode"><span class="id" type="var">P</span></span>有它的 <i>证明</i> 作为它的元素。我们称这些元素为命题<span class="inlinecode"><span class="id" type="var">P</span></span>的
真实性的 <i>证明项</i> （proof term）/ <i>证明对象</i> （proof object）/ <i>证据</i> （evidence）。
    在Coq中，当我们声明并且证明像这样的引理的时候：

<div class="paragraph"> </div>

<div class="code code-tight">
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">silly</span> : 0 × 3 = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.
<div class="paragraph"> </div>

</div>
    我们在<span class="inlinecode"><span class="id" type="keyword">Proof</span></span>和<span class="inlinecode"><span class="id" type="keyword">Qed</span></span>关键字中使用的证明策略会告诉Coq如何构造出一个作为这个
命题的元素的证明项。在这个示范中，命题<span class="inlinecode">0</span> <span class="inlinecode">×</span> <span class="inlinecode">3</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>被由<span class="inlinecode"><span class="id" type="var">mult</span></span>的定义（它声明了
<span class="inlinecode">0</span> <span class="inlinecode">×</span> <span class="inlinecode">3</span>能够被简化至<span class="inlinecode">3</span>）和相等的 <i>自反性</i> （它声明了<span class="inlinecode">0</span> <span class="inlinecode">=</span> <span class="inlinecode">0</span>）构成的组合证明。

<div class="paragraph"> </div>

<a name="lab193"></a><h3 class="section"> </h3>

</div>
<div class="code code-space">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">silly</span> : 0 × 3 = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们可以用<span class="inlinecode"><span class="id" type="keyword">Print</span></span>指令来查看Coq给某一命题构造的证明项： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">silly</span>.<br/>
<span class="comment">(* ===> silly = eq_refl : 0 * 3 = 0 *)</span><br/>

<br/>
</div>

<div class="doc">
在这里，证明项<span class="inlinecode"><span class="id" type="var">eq_refl</span></span>证实了它的相等性。（我们会在将来遇到更多的关于相等性的内容。
<div class="paragraph"> </div>

<a name="lab194"></a><h2 class="section">蕴含 <i>是</i> 函数</h2>

<div class="paragraph"> </div>

 就像我们能够以函数的形式实现自然数乘法一样：
<span class="inlinecode"></span>
<span class="inlinecode"><span class="id" type="var">mult</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">nat</span></span> 
<span class="inlinecode"></span>
一个蕴含式<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">→</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证明项是一个 <i>函数</i> ；这个函数以命题<span class="inlinecode"><span class="id" type="var">P</span></span>的证据作为输入，并且生成一个<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据作为其输出。

</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="var">silly_implication</span> : (1 + 1) = 2  <span style="font-family: arial;">→</span>  0 × 3 = 0.<br/>
<span class="id" type="keyword">Proof</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
我们能够看到上面的引理的证明项确实是一个函数： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Print</span> <span class="id" type="var">silly_implication</span>.<br/>
<span class="comment">(* ===> silly_implication = fun _ : 1 + 1 = 2 => eq_refl<br/>
     : 1 + 1 = 2 -> 0 * 3 = 0 *)</span><br/>

<br/>
</div>

<div class="doc">
<a name="lab195"></a><h2 class="section">定义命题</h2>

<div class="paragraph"> </div>

 就像我们能够创建自定义的归纳性类型（比如说列表和二进制表示的自然数这些
我们之前曾接触过的类型）一样，我们也能够创建 <i>自定义的</i> 命题。

<div class="paragraph"> </div>

    问题：你如何定义某个命题的意义？

<div class="paragraph"> </div>

<a name="lab196"></a><h3 class="section"> </h3>

<div class="paragraph"> </div>

 命题的意义由说明了如何从其他证据构造出证实命题为真的 <i>证据</i> 的 <i>规则</i> 和 <i>定义</i> 给出。

<div class="paragraph"> </div>

<ul class="doclist">
<li> 一般而言，就像其他数据类型一样，规则是被归纳性地定义的。

<div class="paragraph"> </div>


</li>
<li> 有时一个命题会在没有支持证据的情况下被宣称为真。这些命题被称作 <i>公理</i> 。

</li>
</ul>
    在这一章以及接下来的章节中，我们将会看到更多的有关这些证明项如何产生效果的细节。

</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab197"></a><h1 class="section">合取（逻辑与）</h1>

<div class="paragraph"> </div>

 命题<span class="inlinecode"><span class="id" type="var">P</span></span>和<span class="inlinecode"><span class="id" type="var">Q</span></span>的逻辑合取能够用包含一个构造子的<span class="inlinecode"><span class="id" type="keyword">Inductive</span></span>定义表示。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">and</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
  <span class="id" type="var">conj</span> : <span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> (<span class="id" type="var">and</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>).<br/>

<br/>
</div>

<div class="doc">
在这个定义背后的直觉十分直接：为了构造<span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证据，我们需要提供
    P的证据和Q的证据。更为精确的说：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 如果<span class="inlinecode"><span class="id" type="var">p</span></span>是<span class="inlinecode"><span class="id" type="var">P</span></span>的证据且<span class="inlinecode"><span class="id" type="var">q</span></span>是<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据，那么<span class="inlinecode"><span class="id" type="var">conj</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span>可以被作为<span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证据；

</li>
<li> 而且这也是 <i>唯一</i> 给出<span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证据的方法。也即是说，如果谁给出了一个<span class="inlinecode"><span class="id" type="var">and</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>
      的证据，那么我们就能够得知这个证据一定是以<span class="inlinecode"><span class="id" type="var">conj</span></span> <span class="inlinecode"><span class="id" type="var">p</span></span> <span class="inlinecode"><span class="id" type="var">q</span></span>这一形式出现的，其中<span class="inlinecode"><span class="id" type="var">p</span></span>是
      <span class="inlinecode"><span class="id" type="var">P</span></span>的证据，<span class="inlinecode"><span class="id" type="var">q</span></span>是<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据。

</li>
</ul>

<div class="paragraph"> </div>

   因为我们会经常使用合取，所以让我们来给它设定一个熟悉的中缀表示符： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">∧</span> Q" := (<span class="id" type="var">and</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
（<span class="inlinecode"><span class="id" type="var">type_scope</span></span>这一标记告诉Coq系统这个符号将会出现在命题中而不是在值中。） 
<div class="paragraph"> </div>

 判断构造子<span class="inlinecode"><span class="id" type="var">conj</span></span>的"类型"： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">conj</span>.<br/>
<span class="comment">(* ===>  forall P Q : Prop, P -> Q -> P /\ Q *)</span><br/>

<br/>
</div>

<div class="doc">
注意，conj需要四个输入——即命题P，命题Q，以及P和Q的证据——然后返回一个P/\Q的证据。 
<div class="paragraph"> </div>

<a name="lab198"></a><h2 class="section">"引入"合取</h2>
 除了从一个极小的基础建立起一切的简洁之外，这样定义合取还有另外一个好
处：我们能够使用我们已经知道的证明策略来证明含有合取的陈述。比方说，如
果目标是一个合取式，我们能够应用<span class="inlinecode"><span class="id" type="var">conj</span></span>这个单独的构造子，而（这可以从
<span class="inlinecode"><span class="id" type="var">conj</span></span>的类型得知）这将证明当前的目标，并且将构成合取的两个部分留下作为两
个需要分别证明的子目标。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_example</span> : <br/>
  (0 = 0) <span style="font-family: arial;">∧</span> (4 = <span class="id" type="var">mult</span> 2 2).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">apply</span> <span class="id" type="var">conj</span>.<br/>
  - <span class="comment">(* left *)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
  - <span class="comment">(* right *)</span> <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
出于方便，我们可以用<span class="inlinecode"><span class="id" type="tactic">split</span></span>作为<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">conj</span></span>的缩写形式。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_example'</span> : <br/>
  (0 = 0) <span style="font-family: arial;">∧</span> (4 = <span class="id" type="var">mult</span> 2 2).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">split</span>.<br/>
    - <span class="comment">(* left *)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
    - <span class="comment">(* right *)</span> <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab199"></a><h2 class="section">"消去"合取</h2>
 相反地，<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>这一策略可以分析并计算出构造出上下文中的某个合取式所
必须的证据，并且将这些证据以变量的形式添加到当前证明的上下文中。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">proj1</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
  <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab200"></a><h4 class="section">Exercise: 1 star, optional (proj2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">proj2</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_commut</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HQ</span>].<br/>
  <span class="id" type="tactic">split</span>.<br/>
    - <span class="comment">(* left *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
    - <span class="comment">(* right *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab201"></a><h4 class="section">Exercise: 2 stars (and_assoc)</h4>
 注意在下面的这个证明中<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>使用的 <i>嵌套模式</i> 是如何将前提<span class="inlinecode"><span class="id" type="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∧</span></span> <span class="inlinecode">(<span class="id" type="var">Q</span></span> <span class="inlinecode"><span style="font-family: arial;">∧</span></span> <span class="inlinecode"><span class="id" type="var">R</span>)</span>
    解构成<span class="inlinecode"><span class="id" type="var">HP</span>:</span> <span class="inlinecode"><span class="id" type="var">P</span></span>，<span class="inlinecode"><span class="id" type="var">HQ</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">Q</span></span>以及<span class="inlinecode"><span class="id" type="var">HR</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="var">R</span></span>的。从这里开始完成这个证明： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">and_assoc</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">→</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">∧</span> <span class="id" type="var">R</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
<span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab202"></a><h1 class="section">Iff</h1>

<div class="paragraph"> </div>

 简便的"当且仅当"连接符只是两个蕴含式的合取： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">iff</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) := (<span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">∧</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>).<br/>

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">↔</span> Q" := (<span class="id" type="var">iff</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) <br/>
                      (<span class="id" type="tactic">at</span> <span class="id" type="var">level</span> 95, <span class="id" type="var">no</span> <span class="id" type="var">associativity</span>) <br/>
                      : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_implies</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> <span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>]. <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_sym</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>, <br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HAB</span> <span class="id" type="var">HBA</span>].<br/>
  <span class="id" type="tactic">split</span>.<br/>
    - <span class="comment">(* -> *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HBA</span>.<br/>
    - <span class="comment">(* <- *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">HAB</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab203"></a><h4 class="section">Exercise: 1 star, optional (iff_properties)</h4>
 以上面的<span class="inlinecode"><span style="font-family: arial;">↔</span></span>的对称性的证明（<span class="inlinecode"><span class="id" type="var">iff_sym</span></span>）作为参考，证明它的自反性和传递性。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_refl</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">iff_trans</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>, <br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">→</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">↔</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
提示：如果在上下文中存在一个“当且仅当”形式的前提，你可以使用<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>
    将其分解为两个单独的蕴含式。（思考一下为什么可以这么做）  <font size=-2>☐</font> 
<div class="paragraph"> </div>

 Coq的某些策略会以特别的方式处理<span class="inlinecode"><span class="id" type="var">iff</span></span>式并因此在使用这些命题
    进行推理时得以避开进行某些底层操控的需要。举例而言，<span class="inlinecode"><span class="id" type="tactic">rewrite</span></span>除了
    可以配合等式使用之外，还可以配合<span class="inlinecode"><span class="id" type="var">iff</span></span>式使用。
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab204"></a><h1 class="section">析取（逻辑或）</h1>

<div class="paragraph"> </div>

<a name="lab205"></a><h2 class="section">实现析取</h2>

<div class="paragraph"> </div>

 析取（逻辑或）也可以被定义为一个归纳性命题。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">or</span> (<span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>) : <span class="id" type="keyword">Prop</span> :=<br/>
  | <span class="id" type="var">or_introl</span> : <span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">or</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span><br/>
  | <span class="id" type="var">or_intror</span> : <span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> <span class="id" type="var">or</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>.<br/>

<br/>
<span class="id" type="keyword">Notation</span> "P <span style="font-family: arial;">∨</span> Q" := (<span class="id" type="var">or</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
判断构造子<span class="inlinecode"><span class="id" type="var">or_introl</span></span>的"类型"：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">or_introl</span>.<br/>
<span class="comment">(* ===>  forall P Q : Prop, P -> P \/ Q *)</span><br/>

<br/>
</div>

<div class="doc">
它有三个输入参数，也就是命题<span class="inlinecode"><span class="id" type="var">P</span></span>，命题<span class="inlinecode"><span class="id" type="var">Q</span></span>以及命题<span class="inlinecode"><span class="id" type="var">P</span></span>的证据，然后输出命题<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>
的证据作为返回值。
    接下来看看<span class="inlinecode"><span class="id" type="var">or_intror</span></span>的类型： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">or_intror</span>.<br/>
<span class="comment">(* ===>  forall P Q : Prop, Q -> P \/ Q *)</span><br/>

<br/>
</div>

<div class="doc">
就像<span class="inlinecode"><span class="id" type="var">or_introl</span></span>一样，只不过它要求的不是<span class="inlinecode"><span class="id" type="var">P</span></span>的证据而是<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据。 
<div class="paragraph"> </div>

 直觉上，有两种给出命题<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的证据的方式：

<div class="paragraph"> </div>

<ul class="doclist">
<li> 给出<span class="inlinecode"><span class="id" type="var">P</span></span>的证据（并且声明你是在给<span class="inlinecode"><span class="id" type="var">P</span></span>提供证据——这正是<span class="inlinecode"><span class="id" type="var">or_introl</span></span>构造子的功能）；

</li>
<li> 或者给出<span class="inlinecode"><span class="id" type="var">Q</span></span>的证据，并用构造子<span class="inlinecode"><span class="id" type="var">or_intror</span></span>标记。
</li>
</ul>

<div class="paragraph"> </div>

<a name="lab206"></a><h3 class="section"> </h3>
 因为<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>有两个构造子，对一个类型为<span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode"><span class="id" type="var">Q</span></span>的前提进行<span class="inlinecode"><span class="id" type="tactic">destruct</span></span>将会生成两个子目标。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_commut</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">Q</span>  <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | <span class="id" type="var">HQ</span>].<br/>
    - <span class="comment">(* left *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">or_intror</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
    - <span class="comment">(* right *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">or_introl</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
从现在开始开始我们将会用两个作为缩写的策略：<span class="inlinecode"><span class="id" type="var">left</span></span>和<span class="inlinecode"><span class="id" type="var">right</span></span>来分别代替
<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">or_introl</span></span>和<span class="inlinecode"><span class="id" type="tactic">apply</span></span> <span class="inlinecode"><span class="id" type="var">or_intror</span></span>。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_commut'</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">Q</span>  <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | <span class="id" type="var">HQ</span>].<br/>
    - <span class="comment">(* left *)</span> <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
    - <span class="comment">(* right *)</span> <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_distributes_over_and_1</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">→</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">∧</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> | [<span class="id" type="var">HQ</span> <span class="id" type="var">HR</span>]].<br/>
    - <span class="comment">(* left *)</span> <span class="id" type="tactic">split</span>.<br/>
      + <span class="comment">(* left *)</span> <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
      + <span class="comment">(* right *)</span> <span class="id" type="var">left</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HP</span>.<br/>
    - <span class="comment">(* right *)</span> <span class="id" type="tactic">split</span>.<br/>
      + <span class="comment">(* left *)</span> <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HQ</span>.<br/>
      + <span class="comment">(* right *)</span> <span class="id" type="var">right</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">HR</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab207"></a><h4 class="section">Exercise: 2 stars (or_distributes_over_and_2)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_distributes_over_and_2</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">∧</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">→</span> <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab208"></a><h4 class="section">Exercise: 1 star, optional (or_distributes_over_and)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">or_distributes_over_and</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">R</span> : <span class="id" type="keyword">Prop</span>,<br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> (<span class="id" type="var">Q</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">R</span>) <span style="font-family: arial;">↔</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">∧</span> (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">R</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab209"></a><h2 class="section">将<span class="inlinecode"><span style="font-family: arial;">∧</span></span>和<span class="inlinecode"><span style="font-family: arial;">∨</span></span>与<span class="inlinecode"><span class="id" type="var">andb</span></span>和<span class="inlinecode"><span class="id" type="var">orb</span></span>联系起来</h2>

<div class="paragraph"> </div>

 我们已经在Coq的计算（<span class="inlinecode"><span class="id" type="keyword">Type</span></span>）和逻辑（<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>）领域中看到了几个使用了模拟结
构的地方。这里是另外一个：布尔运算操作符<span class="inlinecode"><span class="id" type="var">andb</span></span>和<span class="inlinecode"><span class="id" type="var">orb</span></span>，很明显地，是对逻辑
连接符<span class="inlinecode"><span style="font-family: arial;">∧</span></span>和<span class="inlinecode"><span style="font-family: arial;">∨</span></span>的模拟。通过以下这些说明了如何将与<span class="inlinecode"><span class="id" type="var">andb</span></span>和<span class="inlinecode"><span class="id" type="var">orb</span></span>在某些输入上的行
为相关的知识转化成与这些输入相关的命题性的事实的定理，这种模拟能够变得
更加精确。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_prop</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
  <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
    - <span class="comment">(* b = true *)</span> <span class="id" type="tactic">destruct</span> <span class="id" type="var">c</span>.<br/>
      + <span class="comment">(* c = true *)</span> <span class="id" type="tactic">apply</span> <span class="id" type="var">conj</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="tactic">reflexivity</span>.<br/>
      + <span class="comment">(* c = false *)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>.<br/>
    - <span class="comment">(* b = false *)</span> <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_true_intro</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
  <span class="id" type="var">b</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">→</span> <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span>.<br/>
  <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">rewrite</span> <span class="id" type="var">H0</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab210"></a><h4 class="section">Exercise: 2 stars, optional (andb_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">andb_false</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
  <span class="id" type="var">andb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">c</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab211"></a><h4 class="section">Exercise: 2 stars, optional (orb_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">orb_prop</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
  <span class="id" type="var">orb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> = <span class="id" type="var">true</span> <span style="font-family: arial;">∨</span> <span class="id" type="var">c</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab212"></a><h4 class="section">Exercise: 2 stars, optional (orb_false_elim)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">orb_false_elim</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> <span class="id" type="var">c</span>,<br/>
  <span class="id" type="var">orb</span> <span class="id" type="var">b</span> <span class="id" type="var">c</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">∧</span> <span class="id" type="var">c</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab213"></a><h1 class="section">矛盾式</h1>

<div class="paragraph"> </div>

 在Coq中矛盾式可以用一个没有构造子的归纳定义的命题表示。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="var">False</span> : <span class="id" type="keyword">Prop</span> := .<br/>

<br/>
</div>

<div class="doc">
在直观上<span class="inlinecode"><span class="id" type="var">False</span></span>是一个无法给出证据的命题。
<div class="paragraph"> </div>

 因为<span class="inlinecode"><span class="id" type="var">False</span></span>没有构造子，对一个类型为<span class="inlinecode"><span class="id" type="var">False</span></span>的假设进行反演将不会生成任何子目
标，由此我们得以立即证明任何目标。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">False_implies_nonsense</span> :<br/>
  <span class="id" type="var">False</span> <span style="font-family: arial;">→</span> 2 + 2 = 5.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>.<br/>
  <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
它是如何产生效果的？策略<span class="inlinecode"><span class="id" type="tactic">inversion</span></span>将<span class="inlinecode"><span class="id" type="var">contra</span></span>分解成各个可能出现的情况并为
每一种情况生成一个子目标。因为<span class="inlinecode"><span class="id" type="var">contra</span></span>作为<span class="inlinecode"><span class="id" type="var">False</span></span>的证据 <i>并没有</i> 可能出现的
情况，因此这里没有可能出现的子目标，而证明因此得以完成。 
<div class="paragraph"> </div>

<a name="lab214"></a><h3 class="section"> </h3>
 相反地，证明<span class="inlinecode"><span class="id" type="var">False</span></span>的唯一方法就是让当前上下文中存在谬误或者矛盾： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">nonsense_implies_False</span> :<br/>
  2 + 2 = 5 <span style="font-family: arial;">→</span> <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">contra</span>.<br/>
  <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
事实上<span class="inlinecode"><span class="id" type="var">False_implies_nonsense</span></span>的证明并不与任何特定的被证明的谬误有关，
    因此它可以很容易地被一般化并且变得可以用在任意命题<span class="inlinecode"><span class="id" type="var">P</span></span>上：
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">ex_falso_quodlibet</span> : <span style="font-family: arial;">∀</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>),<br/>
  <span class="id" type="var">False</span> <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">contra</span>.<br/>
  <span class="id" type="tactic">inversion</span> <span class="id" type="var">contra</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<i>ex falso quodlibet</i> 是拉丁文，它的字面意思是：“从谬误出发你能证明
    任何你想要证明的命题”。这一定理也被称作 <i>爆炸原理</i> 。 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab215"></a><h2 class="section">真值</h2>

<div class="paragraph"> </div>

 因为我们已经在Coq中定义了矛盾式，有人也许会想知道我们是否能够用相同的方式定义真值。我们能够这么做。 
<div class="paragraph"> </div>

<a name="lab216"></a><h4 class="section">Exercise: 2 stars, advanced (True)</h4>
 将<span class="inlinecode"><span class="id" type="var">True</span></span>定义为一个归纳定义的命题。（从直觉上说<span class="inlinecode"><span class="id" type="var">True</span></span>应该是一个能平凡地给出证据的命题。） 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(* FILL IN HERE *)</span><br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

 然而不像我们将会经常使用的<span class="inlinecode"><span class="id" type="var">False</span></span>，<span class="inlinecode"><span class="id" type="var">True</span></span>极少被使用到。就自身而言，它是个
过于平凡（因此也变得无趣）的证明目标，在作为证明的前提时也不包含任何有
用的信息。但是在定义复杂的、使用到了条件式的<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的时候，或者作为高阶
<span class="inlinecode"><span class="id" type="keyword">Prop</span></span>的参数的时候，<span class="inlinecode"><span class="id" type="var">True</span></span>是十分有用的。 
</div>
<div class="code code-tight">

<br/>
</div>

<div class="doc">
<a name="lab217"></a><h1 class="section">否定</h1>

<div class="paragraph"> </div>

 命题<span class="inlinecode"><span class="id" type="var">P</span></span>的逻辑上的补写作<span class="inlinecode"><span class="id" type="var">not</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span>，或者使用缩写形式<span class="inlinecode">¬<span class="id" type="var">P</span></span>： 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">not</span> (<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>) := <span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">False</span>.<br/>

<br/>
</div>

<div class="doc">
在这背后的直觉是：如果<span class="inlinecode"><span class="id" type="var">P</span></span>不为真，则任何命题，甚至<span class="inlinecode"><span class="id" type="var">False</span></span>，都能在假设<span class="inlinecode"><span class="id" type="var">P</span></span>的情况下证明。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "¬ x" := (<span class="id" type="var">not</span> <span class="id" type="var">x</span>) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
<span class="id" type="keyword">Check</span> <span class="id" type="var">not</span>.<br/>
<span class="comment">(* ===> Prop -> Prop *)</span><br/>

<br/>
</div>

<div class="doc">
在习惯在Coq中处理否定之前仍需要一点练习。有时即使你完全明白为什么某些
命题为真，在最开始的时候通过适当的设置让Coq系统接受这一点也是有一点
困难的。这里有一些常见事实的证明，作为在这之前的热身。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_False</span> : <br/>
  ¬ <span class="id" type="var">False</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab218"></a><h3 class="section"> </h3>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contradiction_implies_anything</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> ¬<span class="id" type="var">P</span>) <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">Q</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">H</span> <span class="id" type="keyword">as</span> [<span class="id" type="var">HP</span> <span class="id" type="var">HNA</span>]. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HNA</span>.<br/>
  <span class="id" type="tactic">apply</span> <span class="id" type="var">HNA</span> <span class="id" type="keyword">in</span> <span class="id" type="var">HP</span>. <span class="id" type="tactic">inversion</span> <span class="id" type="var">HP</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">double_neg</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">→</span> ~~<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span>. <span class="id" type="tactic">intros</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">G</span>. <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab219"></a><h4 class="section">Exercise: 2 stars, advanced (double_neg_inf)</h4>
 写下命题<span class="inlinecode"><span class="id" type="var">double_neg</span></span>的非形式证明：

<div class="paragraph"> </div>

   <i>定理</i> : 对于任意命题<span class="inlinecode"><span class="id" type="var">P</span></span>，<span class="inlinecode"><span class="id" type="var">P</span></span>蕴含<span class="inlinecode">~~<span class="id" type="var">P</span></span>。

<div class="paragraph"> </div>

   <i>证明</i>  :

<div class="paragraph"> </div>

<span class="comment">(* FILL IN HERE *)</span><br/>
   <font size=-2>☐</font>

<div class="paragraph"> </div>

<a name="lab220"></a><h4 class="section">Exercise: 2 stars (contrapositive)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">contrapositive</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span> : <span class="id" type="keyword">Prop</span>,<br/>
  (<span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> (¬<span class="id" type="var">Q</span> <span style="font-family: arial;">→</span> ¬<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab221"></a><h4 class="section">Exercise: 1 star (not_both_true_and_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_both_true_and_false</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
  ¬ (<span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> ¬<span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab222"></a><h4 class="section">Exercise: 1 star, advanced (informal_not_PNP)</h4>
 写下命题<span class="inlinecode"><span style="font-family: arial;">∀</span></span> <span class="inlinecode"><span class="id" type="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" type="keyword">Prop</span>,</span> <span class="inlinecode">~(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∧</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>的非形式证明 
</div>
<div class="code code-tight">

<br/>
<span class="comment">(* FILL IN HERE *)</span><br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab223"></a><h3 class="section">构造性逻辑</h3>
 注意，有些在经典逻辑下成立的定理在Coq的构造性逻辑中是不可证的。

<div class="paragraph"> </div>

让我们看看下面这个证明是如何无法进行下去的，以作为这一事实的例证……
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">classic_double_neg</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> : <span class="id" type="keyword">Prop</span>,<br/>
  ~~<span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* WORKED IN CLASS *)</span><br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">P</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
  <span class="comment">(* 然后呢？我们没有办法基于<span class="inlinecode"><span class="id" type="var">P</span></span>的证据“发明”出命题<span class="inlinecode">¬<span class="id" type="var">P</span></span>的证据。*)</span><br/>
  <span class="id" type="keyword">Abort</span>.<br/>
</div>

<div class="doc">
<a name="lab224"></a><h4 class="section">Exercise: 5 stars, advanced, optional (classical_axioms)</h4>
 对于那些喜欢挑战的人，这里有一个摘自Coq'Art（第123页）的练习。下面是五
条常常被认为是刻画了经典逻辑（与Coq"内置"的构造性逻辑相对）的语句。在
Coq中我们无法证明它们，但是如果我们希望处理在经典逻辑下的问题，我们能
够将它们之中的任意一句作为一个没有证明的公理加进Coq之中而不损它的一致
性。试证这五个命题互相等价。 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">peirce</span> := <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>: <span class="id" type="keyword">Prop</span>, <br/>
  ((<span class="id" type="var">P</span><span style="font-family: arial;">→</span><span class="id" type="var">Q</span>)<span style="font-family: arial;">→</span><span class="id" type="var">P</span>)<span style="font-family: arial;">→</span><span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">classic</span> := <span style="font-family: arial;">∀</span><span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>, <br/>
  ~~<span class="id" type="var">P</span> <span style="font-family: arial;">→</span> <span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">excluded_middle</span> := <span style="font-family: arial;">∀</span><span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>, <br/>
  <span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> ¬<span class="id" type="var">P</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">de_morgan_not_and_not</span> := <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>, <br/>
  ~(~<span class="id" type="var">P</span> <span style="font-family: arial;">∧</span> ¬<span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> <span class="id" type="var">P</span><span style="font-family: arial;">∨</span><span class="id" type="var">Q</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="var">implies_to_or</span> := <span style="font-family: arial;">∀</span><span class="id" type="var">P</span> <span class="id" type="var">Q</span>:<span class="id" type="keyword">Prop</span>, <br/>
  (<span class="id" type="var">P</span><span style="font-family: arial;">→</span><span class="id" type="var">Q</span>) <span style="font-family: arial;">→</span> (¬<span class="id" type="var">P</span><span style="font-family: arial;">∨</span><span class="id" type="var">Q</span>).<br/>

<br/>
<span class="comment">(* FILL IN HERE *)</span><br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab225"></a><h4 class="section">Exercise: 3 stars (excluded_middle_irrefutable)</h4>
 这一定理蕴含了一个事实：对于任意 <i>特定的</i> 命题<span class="inlinecode"><span class="id" type="var">P</span></span>，可以添加任意一个可判定性
    公理（比如说排中律的一个实例）而不损安全性。为什么？因为我们不能证明这
样一个公理的否定；如果我们能够这么做，我们将会同时有<span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode"><span class="id" type="var">P</span>)</span>和<span class="inlinecode">¬</span> <span class="inlinecode">¬</span> <span class="inlinecode">(<span class="id" type="var">P</span></span> <span class="inlinecode"><span style="font-family: arial;">∨</span></span> <span class="inlinecode">¬<span class="id" type="var">P</span>)</span>，
    而这是一个矛盾。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">excluded_middle_irrefutable</span>: <span style="font-family: arial;">∀</span>(<span class="id" type="var">P</span>:<span class="id" type="keyword">Prop</span>), <br/>
    ¬ ¬ (<span class="id" type="var">P</span> <span style="font-family: arial;">∨</span> ¬ <span class="id" type="var">P</span>).<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab226"></a><h2 class="section">不等式</h2>

<div class="paragraph"> </div>

 声明<span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span></span>实际上就是在声明<span class="inlinecode">~(<span class="id" type="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">y</span>)</span>. 
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Notation</span> "x ≠ y" := (¬ (<span class="id" type="var">x</span> = <span class="id" type="var">y</span>)) : <span class="id" type="var">type_scope</span>.<br/>

<br/>
</div>

<div class="doc">
因为不等式包含了一个否定，所以学会流畅地处理不等式也需要一点练习。这里
是一个十分有用的技巧。如果你正试图证明一个荒谬的目标（比如说，
<span class="inlinecode"><span class="id" type="var">false</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" type="var">true</span></span>），可以应用<span class="inlinecode"><span class="id" type="var">ex_falso_quodlibet</span></span>将其转换成
<span class="inlinecode"><span class="id" type="var">False</span></span>，这样可以更简单地利用在上下文当中的有着<span class="inlinecode">¬<span class="id" type="var">P</span></span>形式的假设——比方说，形
如<span class="inlinecode"><span class="id" type="var">x</span></span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" type="var">y</span></span>的假设。
</div>
<div class="code code-tight">

<br/>
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">not_false_then_true</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">b</span> : <span class="id" type="var">bool</span>,<br/>
  <span class="id" type="var">b</span> ≠ <span class="id" type="var">false</span> <span style="font-family: arial;">→</span> <span class="id" type="var">b</span> = <span class="id" type="var">true</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="id" type="tactic">intros</span> <span class="id" type="var">b</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">destruct</span> <span class="id" type="var">b</span>.<br/>
  - <span class="comment">(* b = true *)</span> <span class="id" type="tactic">reflexivity</span>.<br/>
  - <span class="comment">(* b = false *)</span><br/>
    <span class="id" type="tactic">unfold</span> <span class="id" type="var">not</span> <span class="id" type="keyword">in</span> <span class="id" type="var">H</span>.<br/>
    <span class="id" type="tactic">apply</span> <span class="id" type="var">ex_falso_quodlibet</span>.<br/>
    <span class="id" type="tactic">apply</span> <span class="id" type="var">H</span>. <span class="id" type="tactic">reflexivity</span>. <span class="id" type="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab227"></a><h4 class="section">Exercise: 2 stars (false_beq_nat)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">false_beq_nat</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span> : <span class="id" type="var">nat</span>,<br/>
     <span class="id" type="var">n</span> ≠ <span class="id" type="var">m</span> <span style="font-family: arial;">→</span><br/>
     <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">false</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

<a name="lab228"></a><h4 class="section">Exercise: 2 stars, optional (beq_nat_false)</h4>

</div>
<div class="code code-space">
<span class="id" type="keyword">Theorem</span> <span class="id" type="var">beq_nat_false</span> : <span style="font-family: arial;">∀</span><span class="id" type="var">n</span> <span class="id" type="var">m</span>,<br/>
  <span class="id" type="var">beq_nat</span> <span class="id" type="var">n</span> <span class="id" type="var">m</span> = <span class="id" type="var">false</span> <span style="font-family: arial;">→</span> <span class="id" type="var">n</span> ≠ <span class="id" type="var">m</span>.<br/>
<span class="id" type="keyword">Proof</span>.<br/>
  <span class="comment">(* FILL IN HERE *)</span> <span class="id" type="var">Admitted</span>.<br/>
</div>

<div class="doc">
<font size=-2>☐</font> 
<div class="paragraph"> </div>

  
</div>
<div class="code code-tight">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="coqindex.html">Index</a></div>

</div>

</body>
</html>
